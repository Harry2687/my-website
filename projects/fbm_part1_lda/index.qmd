---
title: "Facebook Messenger Data Part 1: Latent Dirichlet Allocation"
description: "Identification and classification of topics in Facebook Messenger conversations using Latent Dirichlet Allocation (LDA)."
categories: [LDA, Python]
author:
  name: Harry Zhong
date: today
# image: 
---

# Introduction

After analysing my Spotify data, I thought it would be interesting to investigate another dataset generated by my online activity: Facebook Messenger chat logs. However, since chat logs are composed of text data we'll have to learn some basic natural language processing techniques to gain any meaningful insights from this dataset.

This is part 1 of 2 of my analysis on my Facebook Messenger conversations, where I'll use latent Dirichlet allocation to (hopefully) identify topics within conversations.

# Data Extraction

First we'll need to load the data, which Facebook provides as a series of `json` files. The raw data is structured like the sample below.

```{python}
with open('sample_messages.json') as file:
    sample = file.read()

print(sample)
```

Ideally though, we'll need to extract the relevant information from each `json` file and store it as a dataframe. In this case only the `messages` property is required. To do this, we'll first import some libraries which we'll need.

```{python}
import os
import json
import pandas as pd
import re
import gensim as gs
```

Then, we can define a function which takes a directory containing `json` files as an input and returns a dataframe using the `messages` property of the `json` files in a `pandas` dataframe.

```{python}
def ms_import_data(directory: str) -> pd.DataFrame:
    data_file_names = os.listdir(directory)
    data_files = [os.path.join(directory, data_file_name) for data_file_name in data_file_names]

    messenger_data = pd.DataFrame()

    for data_file in data_files:
        with open(data_file) as file:
            data = json.load(file)
        json_data = pd.json_normalize(data['messages'])
        messenger_data = pd.concat([messenger_data, json_data])

    messenger_data = (
        messenger_data[[
            'sender_name',
            'timestamp_ms',
            'content'
        ]]
        .dropna()
        .sort_values('timestamp_ms', ascending=True)
    )

    messenger_data['timestamp'] = pd.to_datetime(messenger_data['timestamp_ms'], unit='ms')

    messenger_data = messenger_data[[
        'sender_name',
        'timestamp',
        'content'
    ]]

    return messenger_data
```

My analysis will focus on a group chat called "The Office" which should have the most data, starting from 2019 to early 2024 when Facebook sent me the data. Using the function we just made, we can import the chat logs and look at the resulting dataframe.

```{python}
chat_data = ms_import_data('data/the_office')
chat_data.head(3)
```

Now that we have the raw data, we can move on to additional cleaning which is required for LDA:

1. Convert all text to lower case.
2. Remove non-text characters.
3. Remove messages that aren't part of a conversation (reactions and links).
4. Remove stop words (words which can belong to any topic, such as conjunctions and abbreviations).
5. Group messages into conversations which will be used as documents for LDA.

Points 1 to 3 are fairly straightforward to implement using `pandas`. However, point 4 brings us to our first usage of `gensim`, a Python topic modelling library, where it's used to remove generic stop words from the chat log. Additional stop words specific to the chat are then defined and removed on top of the words from `gensim`.

The code used to implement points 1 to 4 is shown below.

```{python}
#| code-fold: true
#| code-summary: "Preprocessing Code"

def remove_custom_stopwords(document: str, stopwords: list) -> str:
    for word in stopwords:
        pattern = r'\b'+word+r'\b'
        document = re.sub(pattern, '', document).replace('  ', ' ')
    
    return document

def lda_preprocess(dataframe: pd.DataFrame, content_col: str, cleaned_col: str, rm_stopwords: bool=True) -> pd.DataFrame:
    dataframe[cleaned_col] = (
        dataframe[content_col]
        .str.lower()
        .str.strip()
        .str.replace('[^a-z\\s]', '', regex=True) # remove anything that isn't text or spaces
        .str.replace('\\s{2,}', ' ', regex=True) # replace 2+ spaces with single space
    )

    chat_actions = [
        'reacted to your message',
        'https'
    ]

    # remove chat actions which aren't part of the conversation
    dataframe = dataframe[
        ~dataframe[cleaned_col]
        .str.contains(
            '|'.join(chat_actions)
        )
    ]

    # stopwords which are not included in gensim
    custom_stopwords = [
        'aditya',
        'gupta',
        'dhruv',
        'jobanputra',
        'harry',
        'zhong',
        'mansoor',
        'khawaja',
        'saquib',
        'ahmed',
        'anand',
        'karna',
        'chaitany',
        'goyal',
        'himal',
        'pandey',
        'anirudth',
        'sanivarapu',
        'sai',
        'roshan',
        'prashant',
        'u', 
        'lmao', 
        'lol', 
        'ur', 
        'like', 
        'yea', 
        'thats', 
        'nah', 
        'im', 
        'yeh', 
        'dont',
        'yeah', 
        'gonna', 
        'didnt',
        'idk',
        'got',
        'r',
        'sure',
        'come',
        'stuff',
        'k',
        'damn',
        'ez',
        'ill',
        'smh',
        'f',
        'ofc',
        'u',
        'tf',
        'nice',
        'wtf',
        'tbf',
        'ngl',
        'm'
    ]

    if rm_stopwords:
        # remove gensim and custom stopwords
        dataframe.loc[:, cleaned_col] = (
            dataframe[cleaned_col]
            .apply(gs.parsing.preprocessing.remove_stopwords)
            .apply(remove_custom_stopwords, args=(custom_stopwords,))
            .str.strip()
            .str.replace('\\s{2,}', ' ', regex=True)
        )

    return dataframe
```

We can again look at the resulting dataframe.

```{python}
chat_data = lda_preprocess(chat_data, 'content', 'clean_content')
chat_data.head(3)
```

Next we'll move on to separating the chat log into conversations, since LDA assumes our complete body of text is composed of a number of documents. There are a number of ways to split a chat log into sections, such as dividing into sections based on text length. However, ideally each document would have a primary topic which is picked up by LDA. Thus, I settled on grouping messages based on the length of time between each message, if the time between two messages exceeds a certain threshold then those two messages would belong to different conversations. I chose the cutoff to be 10 minutes using the educated guess methodology.

Implementing this logic in `pandas` is fairly simple, one approach is to:

1. Create a column with the difference between the current row and the previous row.
2. Create a boolean column indicating if the time difference is greater than the cutoff.
3. Count the cumulative number of `True` rows as the conversation number.
4. Group by conversation number and concatenate the message content column.
5. Convert conversations from dataframe to list.

This approach is implemented in the function below.

```{python}
def lda_getdocs(dataframe: pd.DataFrame, content_col: str, ts_col: str, conv_cutoff: int=600):
    # calculate difference between each message
    dataframe['time_diff'] = (
        dataframe[ts_col]
        .diff()
        .fillna(pd.Timedelta(seconds=0))
    )
    dataframe['time_diff'] = (
        dataframe['time_diff']
        .dt.total_seconds()
    )

    # group dataframe into different conversations based on cutoff value
    dataframe['new_conv'] = dataframe['time_diff'] > conv_cutoff
    dataframe['conv_num'] = 'Conv ' + (
        dataframe['new_conv']
        .cumsum()
        .astype(str)
    )

    # join together messages in the same coversation
    conversations = (
        dataframe
        .groupby('conv_num')
        [content_col]
        .apply(lambda x: ' '.join(map(str, x)))
        .str.strip()
        .str.replace('\\s{2,}', ' ', regex=True)
        .reset_index()
    )
    conversations = conversations[conversations[content_col] != '']

    documents = conversations[content_col].tolist()

    return documents
```

We can then apply the function to our dataset and view the new columns that were created in our dataframe.

```{python}
documents = lda_getdocs(chat_data, 'clean_content', 'timestamp')
chat_data.head(3)
```

And view a our documents.

```{python}
for doc in documents[0:3]:
    print(doc[0:50] + '...')
```

# Latent Dirichlet Allocation

LDA is an unsupervised machine learning algorithm used for topic discovery within a collection of documents, where a topic is considered to be a distribution of words. LDA models the creation of documents (members of the chat messaging in this case) as a generative process involving two Dirichlet distributions and two multinomial distributions (with one trial).

## Dirichlet Distribution

The Dirichlet distribution is a continuous multivariate distribution, LDA typically uses the symmetric case of the Dirichlet distribution where the parameter is sparse, defined by the probability density function:

$$
f(x_1,...,x_K;\alpha)=\frac{\Gamma(\alpha K)}{\Gamma(\alpha)^K}\prod_{i=1}^{K}x_i^{\alpha-1}
$$

Where $\Gamma(z)$ is the [Gamma function](https://en.wikipedia.org/wiki/Gamma_function), and the following constraints are satisfied:

1. $\alpha <1$ (sparse condition).
2. $K\ge 2$
3. $\sum_{i=1}^K x_i=1$
4. $x_i\in [0,1]$

We can think of a Dirichlet distribution as a distribution of multinomial distributions, where $x_1,...,x_K$ is the sample space of the multinomial distributions. The sparse condition ($\alpha <1$) indicates that the probability density function is greater around the points $x_1,...,x_K$. Constraints 2 to 4 basically allows the domain of the Dirichlet PDF to satisfy the sample space of a multinomial distribution.

This distribution can intuitively be understood as a topic distribution for documents, as documents will typically have very few primary topics, and a sparse Dirichlet distribution will assign a higher probability to multinomial distributions that are heavily weighted to a few outcomes (topics). This works similarly for word distributions for topics, as topics will typically be defined by a handful of words.

## Document Generating Process

Now that we understand the relevant type of Dirichlet distribution, we'll assign some parameters which will define how documents are generated under LDA, let:

- $M$ be the number of documents.
- $N_i$ be the number of words in document $i\in \{1,...,M\}$.
- $K$ be the total number of topics across the $M$ documents.
- $\alpha$ be the symmetric parameter of the Dirichlet distribution for topics within documents.
- $\beta$ be the symmetric parameter of the Dirichlet distribution for words within topics.
- $\theta_i$ be the multinomial topic distribution for document $i\in \{1,...,M\}$.
- $\phi_k$ be the multinomial word distribution for topic $k\in \{1,...,K\}$

So we have $M$ documents which each have a length of $N_i$. To generate documents, we'll first sample $\phi_k\sim Dir(\beta)$ for all $k$. This gives us the multinomial word distribution for each of the $K$ topics. Then, for each document $i$:

1. Sample $\theta_i\sim Dir(\alpha)$. This gives us the multinomial topic distribution for document $i$.
2. Generate word $j\in \{1,...,N_i\}$ in document $i$ by:
    - Sampling a topic from $\theta_i$.
    - Sampling a word from the corresponding $\phi_k$ where $k$ is the topic chosen previously.
3. Repeat for all $i$.

## Training



## Hyperparameter Tuning

# Results