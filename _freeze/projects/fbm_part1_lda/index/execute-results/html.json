{
  "hash": "d35ecbdf067d1f92021dbd4aedc7f130",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Facebook Messenger Data Part 1: Latent Dirichlet Allocation\"\ndescription: \"Identification and classification of topics in Facebook Messenger conversations using Latent Dirichlet Allocation (LDA).\"\ncategories: [LDA, Python]\nauthor:\n  name: Harry Zhong\ndate: 2025-01-05\nimage: topic_chart.png\n---\n\n# Introduction\n\nAfter analysing my Spotify data, I thought it would be interesting to investigate another dataset generated by my online activity: Facebook Messenger chat logs. However, since chat logs are composed of text data we'll have to learn some basic natural language processing techniques to gain any meaningful insights from this dataset.\n\nThis is part 1 of 2 of my analysis on my Facebook Messenger conversations, where I'll use latent Dirichlet allocation to (hopefully) identify topics within conversations.\n\n# Data Extraction\n\nFirst we'll need to load the data, which Facebook provides as a series of `json` files. The raw data is structured like the sample below.\n\n::: {#3cdf2004 .cell execution_count=1}\n``` {.python .cell-code}\nwith open('sample_messages.json') as file:\n    sample = file.read()\n\nprint(sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"participants\": [\n      {\n        \"name\": \"Alice\"\n      },\n      {\n        \"name\": \"Bob\"\n      }\n    ],\n    \"messages\": [\n      {\n        \"sender_name\": \"Alice\",\n        \"timestamp_ms\": 1710762618535,\n        \"content\": \"Hey, Bob! Did you see the new movie?\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Bob\",\n        \"timestamp_ms\": 1710762591958,\n        \"content\": \"Yeah, I just watched it last night. What did you think of it?\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Bob\",\n        \"timestamp_ms\": 1710762583886,\n        \"content\": \"I loved the plot twist at the end. It was so unexpected!\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Alice\",\n        \"timestamp_ms\": 1710749703948,\n        \"content\": \"I know, right? I was totally surprised when it happened.\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Bob\",\n        \"timestamp_ms\": 1710749659963,\n        \"content\": \"What did you think of the special effects?\",\n        \"reactions\": [\n          {\n            \"reaction\": \"\\ud83d\\ude04\",\n            \"actor\": \"Alice\"\n          }\n        ],\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Bob\",\n        \"timestamp_ms\": 1710749648743,\n        \"content\": \"I thought they were really well done. The explosions were so cool!\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Alice\",\n        \"timestamp_ms\": 1710749547622,\n        \"content\": \"Definitely! I loved the action scenes.\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Alice\",\n        \"timestamp_ms\": 1710749516271,\n        \"content\": \"I'm so glad we watched it together. It was a lot more fun that way.\",\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Bob\",\n        \"timestamp_ms\": 1710749502826,\n        \"content\": \"Definitely! We should do it again soon.\",\n        \"reactions\": [\n          {\n            \"reaction\": \"\\ud83d\\ude04\",\n            \"actor\": \"Alice\"\n          }\n        ],\n        \"is_geoblocked_for_viewer\": false\n      },\n      {\n        \"sender_name\": \"Alice\",\n        \"timestamp_ms\": 1710749462947,\n        \"content\": \"Sounds like a plan to me!\",\n        \"is_geoblocked_for_viewer\": false\n      }\n    ]\n  }\n```\n:::\n:::\n\n\nIdeally though, we'll need to extract the relevant information from each `json` file and store it as a dataframe. In this case only the `messages` property is required. To do this, we'll first import some libraries which we'll need.\n\n::: {#c1981c94 .cell execution_count=2}\n``` {.python .cell-code}\nimport os\nimport json\nimport pandas as pd\nimport re\nimport gensim as gs\n```\n:::\n\n\nThen, we can define a function which takes a directory containing `json` files as an input and returns a dataframe using the `messages` property of the `json` files in a `pandas` dataframe.\n\n::: {#098a7590 .cell execution_count=3}\n``` {.python .cell-code}\ndef ms_import_data(directory: str) -> pd.DataFrame:\n    data_file_names = os.listdir(directory)\n    data_files = [os.path.join(directory, data_file_name) for data_file_name in data_file_names]\n\n    messenger_data = pd.DataFrame()\n\n    for data_file in data_files:\n        with open(data_file) as file:\n            data = json.load(file)\n        json_data = pd.json_normalize(data['messages'])\n        messenger_data = pd.concat([messenger_data, json_data])\n\n    messenger_data = (\n        messenger_data[[\n            'sender_name',\n            'timestamp_ms',\n            'content'\n        ]]\n        .dropna()\n        .sort_values('timestamp_ms', ascending=True)\n    )\n\n    messenger_data['timestamp'] = pd.to_datetime(messenger_data['timestamp_ms'], unit='ms')\n\n    messenger_data = messenger_data[[\n        'sender_name',\n        'timestamp',\n        'content'\n    ]]\n\n    return messenger_data\n```\n:::\n\n\nMy analysis will focus on a group chat called \"The Office\" which should have the most data, starting from 2019 to early 2024 when Facebook sent me the data. Using the function we just made, we can import the chat logs and look at the resulting dataframe.\n\n::: {#949c47a6 .cell execution_count=4}\n``` {.python .cell-code}\nchat_data = ms_import_data('data/the_office')\nchat_data.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sender_name</th>\n      <th>timestamp</th>\n      <th>content</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6328</th>\n      <td>Harry Zhong</td>\n      <td>2019-04-08 11:23:07.519</td>\n      <td>You created the group.</td>\n    </tr>\n    <tr>\n      <th>6327</th>\n      <td>Harry Zhong</td>\n      <td>2019-04-08 11:23:08.454</td>\n      <td>Hoi</td>\n    </tr>\n    <tr>\n      <th>6326</th>\n      <td>Dhruv Jobanputra</td>\n      <td>2019-04-08 11:23:19.718</td>\n      <td>Hoi</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNow that we have the raw data, we can move on to additional cleaning which is required for LDA:\n\n1. Convert all text to lower case.\n2. Remove non-text characters.\n3. Remove messages that aren't part of a conversation (reactions and links).\n4. Remove stop words (words which can belong to any topic, such as conjunctions and abbreviations).\n5. Group messages into conversations which will be used as documents for LDA.\n\nPoints 1 to 3 are fairly straightforward to implement using `pandas`. However, point 4 brings us to our first usage of `gensim`, a Python topic modelling library, where it's used to remove generic stop words from the chat log. Additional stop words specific to the chat are then defined and removed on top of the words from `gensim`.\n\nThe code used to implement points 1 to 4 is shown below.\n\n::: {#c829d2a0 .cell execution_count=5}\n``` {.python .cell-code}\n# import custom stopwords\nfrom modules.preprocessing import custom_stopwords\n\ndef remove_custom_stopwords(document: str, stopwords: list) -> str:\n    for word in stopwords:\n        pattern = r'\\b'+word+r'\\b'\n        document = re.sub(pattern, '', document).replace('  ', ' ')\n    \n    return document\n\ndef lda_preprocess(dataframe: pd.DataFrame, content_col: str, cleaned_col: str, rm_stopwords: bool=True) -> pd.DataFrame:\n    dataframe[cleaned_col] = (\n        dataframe[content_col]\n        .str.lower()\n        .str.strip()\n        .str.replace('[^a-z\\\\s]', '', regex=True) # remove anything that isn't text or spaces\n        .str.replace('\\\\s{2,}', ' ', regex=True) # replace 2+ spaces with single space\n    )\n\n    chat_actions = [\n        'reacted to your message',\n        'https'\n    ]\n\n    # remove chat actions which aren't part of the conversation\n    dataframe = dataframe[\n        ~dataframe[cleaned_col]\n        .str.contains(\n            '|'.join(chat_actions)\n        )\n    ]\n\n    if rm_stopwords:\n        # remove gensim and custom stopwords\n        dataframe.loc[:, cleaned_col] = (\n            dataframe[cleaned_col]\n            .apply(gs.parsing.preprocessing.remove_stopwords)\n            .apply(remove_custom_stopwords, args=(custom_stopwords,))\n            .str.strip()\n            .str.replace('\\\\s{2,}', ' ', regex=True)\n        )\n\n    return dataframe\n```\n:::\n\n\nWe can again look at the resulting dataframe.\n\n::: {#75a3841f .cell execution_count=6}\n``` {.python .cell-code}\nchat_data = lda_preprocess(chat_data, 'content', 'clean_content')\nchat_data.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sender_name</th>\n      <th>timestamp</th>\n      <th>content</th>\n      <th>clean_content</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6328</th>\n      <td>Harry Zhong</td>\n      <td>2019-04-08 11:23:07.519</td>\n      <td>You created the group.</td>\n      <td>created group</td>\n    </tr>\n    <tr>\n      <th>6327</th>\n      <td>Harry Zhong</td>\n      <td>2019-04-08 11:23:08.454</td>\n      <td>Hoi</td>\n      <td>hoi</td>\n    </tr>\n    <tr>\n      <th>6326</th>\n      <td>Dhruv Jobanputra</td>\n      <td>2019-04-08 11:23:19.718</td>\n      <td>Hoi</td>\n      <td>hoi</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNext we'll move on to separating the chat log into conversations, since LDA assumes our complete body of text is composed of a number of documents. There are a number of ways to split a chat log into sections, such as dividing into sections based on text length. However, ideally each document would have a primary topic which is picked up by LDA. Thus, I settled on grouping messages based on the length of time between each message, if the time between two messages exceeds a certain threshold then those two messages would belong to different conversations. I chose the cutoff to be 10 minutes using the educated guess methodology.\n\nImplementing this logic in `pandas` is fairly simple, one approach is to:\n\n1. Create a column with the difference between the current row and the previous row.\n2. Create a boolean column indicating if the time difference is greater than the cutoff.\n3. Count the cumulative number of `True` rows as the conversation number.\n4. Group by conversation number and concatenate the message content column.\n5. Convert conversations from dataframe to list.\n\nThis approach is implemented in the function below.\n\n::: {#fc00ccdd .cell execution_count=7}\n``` {.python .cell-code}\ndef lda_getdocs(dataframe: pd.DataFrame, content_col: str, ts_col: str, conv_cutoff: int=600):\n    # calculate difference between each message\n    dataframe['time_diff'] = (\n        dataframe[ts_col]\n        .diff()\n        .fillna(pd.Timedelta(seconds=0))\n    )\n    dataframe['time_diff'] = (\n        dataframe['time_diff']\n        .dt.total_seconds()\n    )\n\n    # group dataframe into different conversations based on cutoff value\n    dataframe['new_conv'] = dataframe['time_diff'] > conv_cutoff\n    dataframe['conv_num'] = 'Conv ' + (\n        dataframe['new_conv']\n        .cumsum()\n        .astype(str)\n    )\n\n    # join together messages in the same coversation\n    conversations = (\n        dataframe\n        .groupby('conv_num')\n        [content_col]\n        .apply(lambda x: ' '.join(map(str, x)))\n        .str.strip()\n        .str.replace('\\\\s{2,}', ' ', regex=True)\n        .reset_index()\n    )\n    conversations = conversations[conversations[content_col] != '']\n\n    documents = conversations[content_col].tolist()\n\n    return documents\n```\n:::\n\n\nWe can then apply the function to our dataset and view the new columns that were created in our dataframe.\n\n::: {#392bb587 .cell execution_count=8}\n``` {.python .cell-code}\ndocuments = lda_getdocs(chat_data, 'clean_content', 'timestamp')\nchat_data.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>sender_name</th>\n      <th>timestamp</th>\n      <th>content</th>\n      <th>clean_content</th>\n      <th>time_diff</th>\n      <th>new_conv</th>\n      <th>conv_num</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6328</th>\n      <td>Harry Zhong</td>\n      <td>2019-04-08 11:23:07.519</td>\n      <td>You created the group.</td>\n      <td>created group</td>\n      <td>0.000</td>\n      <td>False</td>\n      <td>Conv 0</td>\n    </tr>\n    <tr>\n      <th>6327</th>\n      <td>Harry Zhong</td>\n      <td>2019-04-08 11:23:08.454</td>\n      <td>Hoi</td>\n      <td>hoi</td>\n      <td>0.935</td>\n      <td>False</td>\n      <td>Conv 0</td>\n    </tr>\n    <tr>\n      <th>6326</th>\n      <td>Dhruv Jobanputra</td>\n      <td>2019-04-08 11:23:19.718</td>\n      <td>Hoi</td>\n      <td>hoi</td>\n      <td>11.264</td>\n      <td>False</td>\n      <td>Conv 0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAnd view a our documents.\n\n::: {#e03c7624 .cell execution_count=9}\n``` {.python .cell-code}\nfor doc in documents[0:3]:\n    print(doc[0:50] + '...')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncreated group hoi hoi premium tech support named g...\nepisodes grand tour season episode season episode ...\ncute dog sohails shitzoo pubg visited nepam wild a...\n```\n:::\n:::\n\n\n# Latent Dirichlet Allocation\n\nLDA is an unsupervised machine learning algorithm used for topic discovery within a collection of documents, where a topic is considered to be a distribution of words. LDA models the creation of documents (members of the chat messaging in this case) as a generative process involving two Dirichlet distributions and two multinomial distributions (with one trial).\n\n## Dirichlet Distribution\n\nThe Dirichlet distribution is a continuous multivariate distribution, LDA typically uses the symmetric case of the Dirichlet distribution where the parameter is sparse, defined by the probability density function:\n\n$$\nf(x_1,...,x_K;\\alpha)=\\frac{\\Gamma(\\alpha K)}{\\Gamma(\\alpha)^K}\\prod_{i=1}^{K}x_i^{\\alpha-1}\n$$\n\nWhere $\\Gamma(z)$ is the [Gamma function](https://en.wikipedia.org/wiki/Gamma_function), and the following constraints are satisfied:\n\n1. $\\alpha <1$ (sparse condition).\n2. $K\\ge 2$\n3. $\\sum_{i=1}^K x_i=1$\n4. $x_i\\in [0,1]$\n\nWe can think of a Dirichlet distribution as a distribution of multinomial distributions, where $x_1,...,x_K$ is the sample space of the multinomial distributions. The sparse condition ($\\alpha <1$) indicates that the probability density function is greater around the points $x_1,...,x_K$. Constraints 2 to 4 basically allows the domain of the Dirichlet PDF to satisfy the sample space of a multinomial distribution.\n\nThis distribution can intuitively be understood as a topic distribution for documents, as documents will typically have very few primary topics, and a sparse Dirichlet distribution will assign a higher probability to multinomial distributions that are heavily weighted to a few outcomes (topics). This works similarly for word distributions for topics, as topics will typically be defined by a handful of words.\n\n## Document Generating Process\n\nNow that we understand the relevant type of Dirichlet distribution, we'll assign some parameters which will define how documents are generated under LDA, let:\n\n- $M$ be the number of documents.\n- $N_i$ be the number of words in document $i\\in \\{1,...,M\\}$.\n- $K$ be the total number of topics across the $M$ documents.\n- $\\alpha$ be the symmetric parameter of the Dirichlet distribution for topics within documents.\n- $\\beta$ be the symmetric parameter of the Dirichlet distribution for words within topics.\n- $\\theta_i$ be the multinomial topic distribution for document $i\\in \\{1,...,M\\}$.\n- $\\phi_k$ be the multinomial word distribution for topic $k\\in \\{1,...,K\\}$\n\nSo we have $M$ documents which each have a length of $N_i$. To generate documents, we'll first sample $\\phi_k\\sim Dir(\\beta)$ for all $k$. This gives us the multinomial word distribution for each of the $K$ topics. Then, for each document $i$:\n\n1. Sample $\\theta_i\\sim Dir(\\alpha)$. This gives us the multinomial topic distribution for document $i$.\n2. Generate word $j\\in \\{1,...,N_i\\}$ in document $i$ by:\n    - Sampling a topic from $\\theta_i$.\n    - Sampling a word from the corresponding $\\phi_k$ where $k$ is the topic chosen previously.\n3. Repeat for all $i$.\n\n## Training\n\nThe goal of model training is to find the $K$ word distributions and $M$ topic distributions which maximises the likelihood of the model generating the training data given the hyperparameters $\\alpha$, $\\beta$ and $K$. There are various methods to achieve this, we'll be using [`gensim.models.ldamodel.LdaModel`](https://radimrehurek.com/gensim/models/ldamodel.html) which implements [online leaning](https://papers.neurips.cc/paper/2010/file/71f6278d140af599e06ad9bf1ba03cb0-Paper.pdf).\n\n### Coherence Score\n\nNext, to evaluate the performance of trained models we'll use UMass coherence. The idea behind UMass coherence is that words that come from the same topic should appear together in documents more often than not, so we take each word pair from the top $N$ (`gensim` sets this as 20 by default) words of each topic and compare the probability of appearing together vs the probability of appearing by itself. UMass coherence for a topic is defined by the formula below.\n\n$$\nUMass=\\frac{2}{N(N-1)}\\sum_{i=1}^N\\sum_{j=1}^{i-1}\\text{log}(\\frac{\\text{P}(w_i,w_j)+\\epsilon}{\\text{P}(w_j)})\n$$\n\nWhere:\n\n- $(w_i,w_j)$ is a word pair.\n- $\\text{P}()$ is the probability of the word/pair occurring calculated using the frequency observed in the training documents.\n- $\\epsilon=1$ to avoid $\\text{log}(0)$.\n\n### Implementation\n\nWe can then create a class that uses `gensim` to train the model, show the discovered topics and calculate the coherence score as an evaluation metric. For simplicity, we'll leave $\\alpha$ and $\\beta$ as the default value in `LdaModel` which is `1/num_topics`, this leave us with only `num_topics` as a tunable hyperparameter.\n\n::: {#bbb6db92 .cell execution_count=10}\n``` {.python .cell-code}\nclass fbm_lda:\n    def __init__(self, documents):\n        self.documents = documents\n        self.texts = [doc.split() for doc in documents]\n        self.dictionary = gs.corpora.Dictionary(self.texts)\n        self.corpus = [self.dictionary.doc2bow(text) for text in self.texts]\n    \n    def train_lda(self, num_topics, passes=10, random_state=2687):\n        self.num_topics = num_topics\n\n        self.lda_model = gs.models.ldamodel.LdaModel(\n            corpus=self.corpus,\n            num_topics=num_topics,\n            id2word=self.dictionary,\n            passes=passes,\n            random_state=random_state\n        )\n\n        return self.lda_model\n\n    def print_topics(self, num_words=5):\n        for topic in self.lda_model.print_topics(num_topics=self.num_topics, num_words=num_words):\n            print(topic)\n\n    def get_coherence(self, coherence_type='u_mass'):\n        coherence = gs.models.CoherenceModel(\n            model=self.lda_model,\n            texts=self.texts,\n            dictionary=self.dictionary,\n            coherence=coherence_type\n        )\n\n        return coherence.get_coherence()\n```\n:::\n\n\nThis allows us to train a LDA model using our documents given a number of topics and calculate its coherence score.\n\n::: {#f8e92285 .cell execution_count=11}\n``` {.python .cell-code}\nmodel = fbm_lda(documents)\nmodel.train_lda(5)\nmodel.get_coherence()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n-2.206920240598983\n```\n:::\n:::\n\n\n## Hyperparameter Tuning\n\nNaturally, the next step would be to test a range of values for `num_topics` to evaluate which ones gives the best UMass coherence score. This is easily done by extending the LDA class we created previously.\n\n::: {.callout-note}\nAs someone who mainly uses R at work, extending a class with additional functionality like this is pretty neat.\n:::\n\n::: {#e27df9df .cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\n\nclass tune_lda(fbm_lda):\n    def tune(self, n_start, n_stop, step, sort: bool=False):\n        n_topics_values = np.arange(n_start, n_stop, step)\n\n        tuning_results = pd.DataFrame(\n            columns=[\n                'n_topics',\n                'umass_coherence'\n            ]\n        )\n\n        for index in range(len(n_topics_values)):\n            n_topics = n_topics_values[index]\n            self.train_lda(num_topics=n_topics)\n            umass_coherence = self.get_coherence()\n\n            tuning_results.loc[index] = (\n                [n_topics] + \n                [umass_coherence]\n            )\n\n        if sort:\n            tuning_results = tuning_results.sort_values('umass_coherence', ascending=False)\n\n        return tuning_results\n```\n:::\n\n\nThe new class can then easily be used to test values 2 to 20 for `num_topics`.\n\n::: {#02f690a5 .cell execution_count=13}\n``` {.python .cell-code}\ntuning = tune_lda(documents)\ntuning_results = tuning.tune(2, 21, 1)\ntuning_results.plot(x='n_topics')\n```\n:::\n\n\n::: {#c0e58b98 .cell execution_count=14}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-15-output-1.png){width=582 height=429}\n:::\n:::\n\n\n# Results\n\nBased off the hyperparameter tuning plot, we can observe that the UMass coherence tends to decrease (lower performance) as the number of topics increases. While 2 to 4 topics results in the best performance as measures by UMass coherence, I found that 7 topics gives the most sensible topics based on my knowledge of the source data.\n\n::: {#915b7b44 .cell execution_count=15}\n``` {.python .cell-code}\nmodel.train_lda(7)\nmodel.print_topics(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0, '0.029*\"play\" + 0.018*\"game\" + 0.012*\"playing\" + 0.010*\"dog\" + 0.010*\"pubg\" + 0.008*\"watch\" + 0.006*\"fun\" + 0.006*\"games\" + 0.006*\"unlucky\" + 0.005*\"movie\"')\n(1, '0.016*\"car\" + 0.014*\"buy\" + 0.011*\"house\" + 0.011*\"drive\" + 0.010*\"th\" + 0.010*\"money\" + 0.008*\"stonks\" + 0.007*\"rich\" + 0.006*\"dbd\" + 0.005*\"new\"')\n(2, '0.023*\"phone\" + 0.023*\"turn\" + 0.022*\"test\" + 0.018*\"laptop\" + 0.015*\"pc\" + 0.012*\"mac\" + 0.010*\"apple\" + 0.009*\"iphone\" + 0.009*\"gb\" + 0.009*\"windows\"')\n(3, '0.009*\"tennis\" + 0.009*\"play\" + 0.007*\"fat\" + 0.007*\"guy\" + 0.007*\"gym\" + 0.006*\"win\" + 0.006*\"eat\" + 0.006*\"beat\" + 0.006*\"team\" + 0.005*\"point\"')\n(4, '0.011*\"girls\" + 0.010*\"girl\" + 0.007*\"tell\" + 0.006*\"haram\" + 0.006*\"talk\" + 0.005*\"pic\" + 0.005*\"longer\" + 0.005*\"available\" + 0.005*\"mum\" + 0.005*\"shes\"')\n(5, '0.014*\"engineer\" + 0.014*\"group\" + 0.013*\"premium\" + 0.013*\"nickname\" + 0.012*\"windmill\" + 0.012*\"support\" + 0.012*\"scammer\" + 0.011*\"racquet\" + 0.010*\"tech\" + 0.009*\"changed\"')\n(6, '0.013*\"work\" + 0.007*\"uni\" + 0.005*\"data\" + 0.005*\"money\" + 0.005*\"job\" + 0.005*\"hard\" + 0.004*\"unit\" + 0.003*\"science\" + 0.003*\"long\" + 0.003*\"working\"')\n```\n:::\n:::\n\n\nBased on the word distributions, the topics could be named as follows:\n\n- Topic 0: Gaming\n- Topic 1: Cars\n- Topic 2: Technology\n- Topic 3: Fitness\n- Topic 4: Relationships\n- Topic 5: Chat actions\n- Topic 6: Study and work\n\nThese topics are pretty unsurprising given the chat participants (18-23 year old dudes), however it's reassuring that the results produced by LDA are as expected. As a final bit of analysis, we can plot the topic distributions over documents (conversations) to visualise how topics changed over time.\n\n::: {#b4e703c5 .cell execution_count=16}\n``` {.python .cell-code}\ndef lda_plot_topics(model: fbm_lda):\n    document_topics = model.lda_model.get_document_topics(model.corpus, minimum_probability=0)\n    topic_dist_df = pd.DataFrame(document_topics)\n    topic_dist_df = topic_dist_df.map(lambda x: x[1])\n\n    topics = [\n        'Gaming', \n        'Cars', \n        'Technology', \n        'Fitness', \n        'Relationships', \n        'Chat actions', \n        'Study and work'\n    ]\n    plot = (\n        topic_dist_df\n        .plot(\n            kind='bar',\n            xticks=[],\n            title=['', '', '', '', '', '', ''],\n            subplots=True,\n            sharey=True\n        )\n    )\n\n    plot = plot.flat\n    for i, p in enumerate(plot):\n        p.legend([topics[i]], bbox_to_anchor=(1, 1))\n\n    return plot\n\nlda_plot_topics(model)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-17-output-1.png){width=717 height=400}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}